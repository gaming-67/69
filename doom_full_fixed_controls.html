<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Mini DOOM — Fixed Controls (WASD + Thumbstick always visible)</title>
<style>
  :root { --panel: rgba(0,0,0,0.45); --accent: #ffcc22; }
  html,body{height:100%;margin:0;background:#050507;color:#ddd;font-family:system-ui,Segoe UI,Roboto,Arial}
  canvas#world { display:block; width:100vw; height:100vh; background:#000; touch-action:none; }
  #topUI { position:fixed; left:10px; top:10px; background:var(--panel); padding:8px 10px; border-radius:8px; z-index:40; font-size:13px; }
  #flash { pointer-events:none; position:fixed; left:0; top:0; right:0; bottom:0; z-index:80; background:rgba(255,0,0,0); transition: background 120ms linear; }
  #hudBar { position:fixed; left:0; right:0; bottom:0; height:96px; z-index:60; background: linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.85)); display:flex; align-items:center; padding:8px 14px; box-sizing:border-box; gap:18px; border-top:2px solid rgba(255,255,255,0.03); }
  #hudFace { width:84px; height:84px; background:#111; border:2px solid #222; border-radius:6px; box-shadow:0 6px 20px rgba(0,0,0,0.6); }
  #hudStats { color:#fff; font-family:monospace; }
  .statLine { font-size:18px; margin-bottom:6px; }
  .statSmall { font-size:13px; color:#bbb; }
  .btnSmall { background:rgba(255,255,255,0.05); padding:6px 8px; border-radius:6px; cursor:pointer; margin-left:8px; color:#fff; border: none; }
  /* always-visible thumbstick */
  #touchLeft,#touchRight{position:fixed;bottom:18px;z-index:70;}
  #touchLeft{left:18px;width:140px;height:140px}
  #touchRight{right:18px;width:140px;height:140px;display:flex;align-items:center;justify-content:center}
  .joyBase{width:100%;height:100%;border-radius:50%;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;cursor:grab}
  .joyThumb{width:44px;height:44px;border-radius:50%;background:rgba(255,255,255,0.12);transform:translate(0,0)}
  .fireBtn{width:84px;height:84px;border-radius:50%;background:linear-gradient(180deg,#ff6a4a,#d24022);display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700;cursor:pointer}
  /* small message */
  #msg { position:fixed; left:50%; transform:translateX(-50%); top:12px; background:rgba(0,0,0,0.5); padding:8px 12px; border-radius:8px; z-index:40; font-size:13px; }
</style>
</head>
<body>
  <canvas id="world"></canvas>
  <div id="topUI"><strong>Mini DOOM — Fixed Controls</strong><div style="font-size:12px">WASD move · A/D strafe · Mouse look (click) · Shoot: LMB/Space · R reload · L next level</div></div>
  <div id="msg">Reach the <strong style="color:#7bff7b">green exit</strong> tile to advance levels.</div>
  <div id="flash"></div>

  <div id="hudBar">
    <canvas id="hudFace" width="84" height="84"></canvas>
    <div id="hudStats">
      <div class="statLine">HEALTH: <span id="hpText">100</span><span class="statSmall"> / 100</span></div>
      <div class="statLine">AMMO: <span id="ammoText">—</span><span class="statSmall"> (R to reload)</span>
        <button id="btnReload" class="btnSmall">R</button>
        <button id="btnNext" class="btnSmall">L</button>
      </div>
      <div class="statSmall" id="levelName">Level: 1</div>
    </div>
  </div>

  <!-- Always-visible thumbstick + fire -->
  <div id="touchLeft"><div class="joyBase" id="joyBase"><div class="joyThumb" id="joyThumb"></div></div></div>
  <div id="touchRight"><div class="fireBtn" id="fireBtn">FIRE</div></div>

<script>
(() => {
  // ---------- Config ----------
  const TILE = 64;
  const FOV = Math.PI / 3;
  const HALF_FOV = FOV / 2;
  const BASE_RAYS = 300, MOBILE_RAYS = 140;
  const MAX_AMMO = 12, RELOAD_MS = 900;
  const PARTICLE_LIFE = 0.45, PARTICLE_PER_IMPACT = 10;

  // ---------- Levels (pre-made) ----------
  const LEVELS = [
    {
      name: "Training Grounds",
      map: [
"################",
"#..............#",
"#..##....##....#",
"#..##....##....#",
"#..............#",
"#..####..####..#",
"#..#........#..#",
"#..#..##....#..#",
"#..#..##....#..#",
"#..#........#..#",
"#..####..####..#",
"#..............#",
"#.....##.....>.#",
"#..............#",
"#..............#",
"################"
      ],
      spawns: [[8.5,6.5],[12.5,3.5],[6.5,10.5]]
    },
    {
      name: "Factory Maze",
      map: [
"################",
"#....#.....>...#",
"#..##.#..##....#",
"#..##.#..##....#",
"#....#.....#...#",
"#..####..####..#",
"#..#........#..#",
"#..#..##....#..#",
"#..#..##....#..#",
"#..#........#..#",
"#..####..####..#",
"#..............#",
"#.....##.......#",
"#..............#",
"#..............#",
"################"
      ],
      spawns: [[7.5,8.5],[10.5,5.5],[11.5,11.5],[5.5,3.5]]
    }
  ];

  // ---------- Canvas ----------
  const canvas = document.getElementById('world');
  const ctx = canvas.getContext('2d', { alpha:false });
  let W = innerWidth, H = innerHeight;
  let dpr = Math.max(1, window.devicePixelRatio || 1);
  let rays = BASE_RAYS;
  function resize(){
    W = innerWidth; H = innerHeight;
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    canvas.width = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    if (isMobile()) rays = MOBILE_RAYS; else rays = Math.max(180, Math.floor(BASE_RAYS * Math.min(1, W / 1280)));
  }
  window.addEventListener('resize', resize);
  resize();

  // ---------- UI refs ----------
  const flashEl = document.getElementById('flash');
  const hudFace = document.getElementById('hudFace');
  const faceCtx = hudFace.getContext('2d');
  const hpText = document.getElementById('hpText');
  const ammoText = document.getElementById('ammoText');
  const levelNameEl = document.getElementById('levelName');
  document.getElementById('btnReload').addEventListener('click', startReload);
  document.getElementById('btnNext').addEventListener('click', () => loadLevel(currentLevel + 1));

  // touch/thumbstick elements (always visible)
  const touchLeft = document.getElementById('touchLeft');
  const touchRight = document.getElementById('touchRight');
  const joyBase = document.getElementById('joyBase');
  const joyThumb = document.getElementById('joyThumb');
  const fireBtn = document.getElementById('fireBtn');

  function isMobile(){ return navigator.maxTouchPoints && navigator.maxTouchPoints > 0 || /Mobi|Android/i.test(navigator.userAgent); }

  // ---------- State ----------
  let currentLevel = 0;
  let MAP = LEVELS[currentLevel].map;
  let MAP_W = MAP[0].length, MAP_H = MAP.length;

  const player = {
    x: TILE * 3.5,
    y: TILE * 3.5,
    ang: 0.6,
    hp: 100,
    ammo: MAX_AMMO,
    reloading: false
  };

  let enemies = [];
  function spawnEnemies(list){
    enemies = [];
    for (let s of list) enemies.push({ x: s[0]*TILE, y: s[1]*TILE, hp: 60 + Math.floor(Math.random()*40), alive: true, shootCooldown: 0 });
  }
  spawnEnemies(LEVELS[0].spawns);

  const enemyBullets = [];
  const playerBullets = [];
  const particles = [];

  // ---------- Helpers ----------
  function mapAt(mx,my){
    if (mx < 0 || my < 0 || my >= MAP_H || mx >= MAP_W) return '#';
    return MAP[my][mx];
  }
  function isWallAtWorld(x,y){
    const mx = Math.floor(x/TILE), my = Math.floor(y/TILE);
    if (mx<0||my<0||mx>=MAP_W||my>=MAP_H) return true;
    return MAP[my][mx] === '#';
  }
  function isExitTileWorld(x,y){
    const mx = Math.floor(x/TILE), my = Math.floor(y/TILE);
    if (mx<0||my<0||mx>=MAP_W||my>=MAP_H) return false;
    return MAP[my][mx] === '>';
  }
  function hasLineOfSight(x0,y0,x1,y1){
    const ang = Math.atan2(y1-y0, x1-x0);
    const sin = Math.sin(ang), cos = Math.cos(ang);
    let dist = 0;
    while (dist < 4000){
      dist += 8;
      const px = x0 + cos*dist, py = y0 + sin*dist;
      if (isWallAtWorld(px, py)) return false;
      if (Math.hypot(px - x1, py - y1) < 8) return true;
    }
    return false;
  }

  // ---------- Hit flash ----------
  let flashTimer = 0;
  function triggerHitFlash(){ flashTimer = 0.16; flashEl.style.background = 'rgba(255,0,0,0.35)'; }

  // ---------- Particles ----------
  function spawnImpact(x, y, angle, color){
    for (let i=0;i<PARTICLE_PER_IMPACT;i++){
      const a = angle + (Math.random()-0.5)*Math.PI*0.6;
      const speed = 100 + Math.random()*240;
      particles.push({ x, y, vx: Math.cos(a)*speed, vy: Math.sin(a)*speed, life: PARTICLE_LIFE * (0.6 + Math.random()*0.8), color, size: 1 + Math.random()*2 });
    }
  }
  function updateParticles(dt){
    for (let i = particles.length-1; i >= 0; i--){
      const p = particles[i];
      p.life -= dt;
      if (p.life <= 0){ particles.splice(i,1); continue; }
      p.x += p.vx * dt; p.y += p.vy * dt;
      p.vx *= 0.96; p.vy *= 0.96;
    }
  }

  // ---------- Reload / Shooting ----------
  let reloadEndAt = 0;
  function startReload(){
    if (player.reloading) return;
    player.reloading = true; reloadEndAt = performance.now() + RELOAD_MS;
    setTimeout(()=>{ player.ammo = MAX_AMMO; player.reloading = false; updateHUD(); }, RELOAD_MS);
    updateHUD();
  }

  function playerFire(){
    if (player.reloading) return;
    if (player.ammo <= 0){ startReload(); return; }
    player.ammo--;
    const angle = player.ang + (Math.random()-0.5)*0.004;
    playerBullets.push({ x: player.x + Math.cos(angle)*16, y: player.y + Math.sin(angle)*16, vx: Math.cos(angle)*1100, vy: Math.sin(angle)*1100, life: 0.7 });
    for (let e of enemies){ if (!e.alive) continue;
      const dx = e.x - player.x, dy = e.y - player.y; const d = Math.hypot(dx,dy);
      const angTo = Math.atan2(dy,dx); let rel = angTo - angle; rel = ((rel + Math.PI)%(2*Math.PI)) - Math.PI;
      if (Math.abs(rel) < 0.25 && d < 900 && hasLineOfSight(player.x, player.y, e.x, e.y)){
        e.hp -= 38; spawnImpact(e.x, e.y, angTo, '#ffb3b3'); if (e.hp <= 0) e.alive = false; break;
      }
    }
    updateHUD();
  }

  function fireEnemyBullet(enemy, angle){
    const spread = (Math.random()-0.5) * 0.14; const a = angle + spread;
    enemyBullets.push({ x: enemy.x + Math.cos(a)*18, y: enemy.y + Math.sin(a)*18, vx: Math.cos(a)*(360+Math.random()*120), vy: Math.sin(a)*(360+Math.random()*120), life: 3.0, dmg: 10 });
  }

  // ---------- Update enemies & bullets ----------
  function updateEnemies(dt){
    for (let e of enemies){
      if (!e.alive) continue;
      const dx = player.x - e.x, dy = player.y - e.y;
      const d = Math.hypot(dx,dy); const angTo = Math.atan2(dy,dx);
      if (d > 60){
        const speed = 36 + Math.random()*22;
        const nx = Math.cos(angTo)*speed*dt, ny = Math.sin(angTo)*speed*dt;
        if (!isWallAtWorld(e.x + nx, e.y + ny)){ e.x += nx; e.y += ny; }
      } else {
        player.hp -= 18 * dt; if (player.hp < 0) player.hp = 0; triggerHitFlash();
      }
      e.shootCooldown = e.shootCooldown || 0; e.shootCooldown -= dt;
      if (d < 700 && e.shootCooldown <= 0 && hasLineOfSight(e.x, e.y, player.x, player.y)){ fireEnemyBullet(e, angTo); e.shootCooldown = 1.2 + Math.random()*1.6; }
    }
  }

  function updateBullets(dt){
    for (let i = enemyBullets.length-1; i >= 0; i--){
      const b = enemyBullets[i]; b.life -= dt; b.x += b.vx*dt; b.y += b.vy*dt;
      if (b.life <= 0 || isWallAtWorld(b.x, b.y)){ spawnImpact(b.x,b.y, Math.atan2(b.vy,b.vx), '#ffd3a6'); enemyBullets.splice(i,1); continue; }
      if (Math.hypot(b.x - player.x, b.y - player.y) < 16){ player.hp -= b.dmg; if (player.hp < 0) player.hp = 0; spawnImpact(b.x,b.y, Math.atan2(b.y-player.y, b.x-player.x), '#ff8b8b'); triggerHitFlash(); enemyBullets.splice(i,1); continue; }
    }
    for (let i = playerBullets.length-1; i >= 0; i--){
      const b = playerBullets[i]; b.life -= dt; b.x += b.vx*dt; b.y += b.vy*dt;
      if (b.life <= 0 || isWallAtWorld(b.x, b.y)){ spawnImpact(b.x,b.y, Math.atan2(b.vy,b.vx), '#ffd'); playerBullets.splice(i,1); continue; }
      for (let e of enemies){ if (!e.alive) continue; if (Math.hypot(b.x - e.x, b.y - e.y) < 18){ e.hp -= 36; spawnImpact(b.x,b.y, Math.atan2(b.y-e.y, b.x-e.x), '#ffb3b3'); if (e.hp <= 0) e.alive = false; playerBullets.splice(i,1); break; } }
    }
  }

  // ---------- Movement / collision ----------
  function tryMovePlayer(dx, dy){
    if (!isWallAtWorld(player.x + dx, player.y)) player.x += dx;
    if (!isWallAtWorld(player.x, player.y + dy)) player.y += dy;
  }

  // ---------- Raycasting / rendering ----------
  function castSingleRay(ox, oy, angle){
    let a = angle % (Math.PI*2); if (a < 0) a += Math.PI*2;
    const sin = Math.sin(a), cos = Math.cos(a);
    let mapX = Math.floor(ox / TILE), mapY = Math.floor(oy / TILE);
    const deltaDistX = Math.abs(1 / (cos || 1e-6)), deltaDistY = Math.abs(1 / (sin || 1e-6));
    let stepX, stepY, sideDistX, sideDistY;
    if (cos < 0){ stepX = -1; sideDistX = (ox - mapX*TILE) * deltaDistX / TILE; } else { stepX = 1; sideDistX = ((mapX+1)*TILE - ox) * deltaDistX / TILE; }
    if (sin < 0){ stepY = -1; sideDistY = (oy - mapY*TILE) * deltaDistY / TILE; } else { stepY = 1; sideDistY = ((mapY+1)*TILE - oy) * deltaDistY / TILE; }
    let hit=false, side=0, safety=0, hitExit=false;
    while(!hit && safety++ < 4096){
      if (sideDistX < sideDistY){ sideDistX += deltaDistX / TILE; mapX += stepX; side = 0; } else { sideDistY += deltaDistY / TILE; mapY += stepY; side = 1; }
      const c = mapAt(mapX, mapY);
      if (c === '#') hit = true;
      if (c === '>') hitExit = true;
    }
    if (!hit) return { dist: 1e6, hitExit };
    let hitX, hitY, perpDist;
    if (side === 0){ const xHit = mapX*TILE + (stepX === -1 ? TILE : 0); const t = (xHit - ox) / (cos || 1e-6); hitX = ox + cos*t; hitY = oy + sin*t; perpDist = Math.abs((hitX - ox) / (cos || 1e-6)); }
    else { const yHit = mapY*TILE + (stepY === -1 ? TILE : 0); const t = (yHit - oy) / (sin || 1e-6); hitX = ox + cos*t; hitY = oy + sin*t; perpDist = Math.abs((hitY - oy) / (sin || 1e-6)); }
    return { dist: perpDist, hitX, hitY, side, hitExit };
  }

  function projectToScreenX(wx, wy){
    const dx = wx - player.x, dy = wy - player.y;
    const ang = Math.atan2(dy, dx);
    let rel = ang - player.ang; rel = ((rel + Math.PI) % (2*Math.PI)) - Math.PI;
    if (Math.abs(rel) > HALF_FOV + 0.6) return null;
    const sx = (0.5 * (1 + Math.tan(rel) / Math.tan(HALF_FOV))) * W;
    return sx;
  }

  function shadeColor(hex, factor){
    const n = parseInt(hex.slice(1), 16);
    const r = Math.floor(((n>>16)&255) * factor); const g = Math.floor(((n>>8)&255) * factor); const b = Math.floor((n&255) * factor);
    return `rgb(${Math.max(0,r)},${Math.max(0,g)},${Math.max(0,b)})`;
  }

  // ---------- Mini-map ----------
  function drawMiniMap(){
    const scale = 0.14; const pad = 10;
    ctx.save(); ctx.translate(pad, pad); ctx.scale(scale, scale);
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0,0,MAP_W*TILE, MAP_H*TILE);
    ctx.fillStyle = '#999';
    for (let y=0;y<MAP_H;y++) for (let x=0;x<MAP_W;x++) if (MAP[y][x] === '#') ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
    for (let y=0;y<MAP_H;y++) for (let x=0;x<MAP_W;x++) if (MAP[y][x] === '>'){ ctx.fillStyle = '#7bff7b'; ctx.fillRect(x*TILE+4,y*TILE+4,TILE-8,TILE-8); }
    for (let e of enemies) if (e.alive){ ctx.fillStyle='#f55'; ctx.beginPath(); ctx.arc(e.x,e.y,10,0,Math.PI*2); ctx.fill(); }
    ctx.fillStyle = '#ff0'; ctx.beginPath(); ctx.arc(player.x, player.y, 10, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = '#ff0'; ctx.beginPath(); ctx.moveTo(player.x,player.y); ctx.lineTo(player.x + Math.cos(player.ang)*40, player.y + Math.sin(player.ang)*40); ctx.stroke();
    ctx.restore();
  }

  // ---------- HUD face ----------
  function renderFace(){
    const hpPct = Math.max(0, Math.min(100, player.hp)) / 100;
    faceCtx.clearRect(0,0,84,84);
    faceCtx.fillStyle = '#111'; faceCtx.fillRect(0,0,84,84);
    const r = Math.floor(200*(1-hpPct)+40), g = Math.floor(200*hpPct+40);
    faceCtx.fillStyle = `rgb(${r},${g},40)`; faceCtx.fillRect(8,10,68,64);
    faceCtx.fillStyle = '#000';
    const eyeOffsetY = 12 + (1 - hpPct) * 6;
    faceCtx.fillRect(22, eyeOffsetY, 8, 6);
    faceCtx.fillRect(54, eyeOffsetY, 8, 6);
    faceCtx.fillStyle = '#330';
    const mouthY = 52 + (1 - hpPct) * 6;
    faceCtx.fillRect(30, mouthY, 24, 6);
  }

  // ---------- HUD update ----------
  function updateHUD(){
    hpText.textContent = Math.max(0, Math.round(player.hp));
    ammoText.textContent = player.reloading ? 'Reloading...' : `${player.ammo} / ${MAX_AMMO}`;
    levelNameEl.textContent = `Level: ${currentLevel + 1} — ${LEVELS[currentLevel].name}`;
  }

  // ---------- Level loader ----------
  function loadLevel(idx){
    currentLevel = idx % LEVELS.length;
    MAP = LEVELS[currentLevel].map;
    MAP_W = MAP[0].length; MAP_H = MAP.length;
    spawnEnemies(LEVELS[currentLevel].spawns);
    player.x = TILE * 3.5; player.y = TILE * 3.5; player.ang = 0.6;
    player.hp = 100; player.ammo = MAX_AMMO; player.reloading = false;
    enemyBullets.length = 0; playerBullets.length = 0; particles.length = 0;
    updateHUD();
  }

  // ---------- Input handling ----------
  // reliable keyboard: attach to window so pointer lock doesn't block
  const keys = {};
  window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault();
    if (e.code === 'KeyR') startReload();
    if (e.code === 'KeyL') loadLevel(currentLevel + 1);
  });
  window.addEventListener('keyup', e => { keys[e.code] = false; });

  // pointer lock + mouse look
  canvas.addEventListener('click', () => { canvas.requestPointerLock(); });
  window.addEventListener('mousemove', e => { if (document.pointerLockElement === canvas) player.ang += e.movementX * 0.0024; });

  // mouse left click shoots
  canvas.addEventListener('mousedown', e => { if (e.button === 0) playerFire(); });

  // ---------- Thumbstick (always visible) ----------
  // We'll support mouse drag and touch.
  let touchMove = { x:0, y:0, active:false };
  // Utility to set thumb from position
  function setJoyFromCoord(clientX, clientY){
    const r = joyBase.getBoundingClientRect();
    const cx = r.left + r.width/2, cy = r.top + r.height/2;
    let dx = (clientX - cx) / (r.width/2);
    let dy = (clientY - cy) / (r.height/2);
    dx = Math.max(-1, Math.min(1, dx)); dy = Math.max(-1, Math.min(1, dy));
    joyThumb.style.transform = `translate(${dx*36}px,${dy*36}px)`;
    touchMove.x = dx; touchMove.y = dy; touchMove.active = true;
  }
  function resetJoy(){ joyThumb.style.transform = 'translate(0,0)'; touchMove.active = false; touchMove.x = 0; touchMove.y = 0; }

  // Mouse drag on joyBase
  let joyMouseDown = false;
  joyBase.addEventListener('mousedown', e => { e.preventDefault(); joyMouseDown = true; setJoyFromCoord(e.clientX, e.clientY); });
  window.addEventListener('mousemove', e => { if (joyMouseDown) setJoyFromCoord(e.clientX, e.clientY); });
  window.addEventListener('mouseup', e => { if (joyMouseDown){ joyMouseDown = false; resetJoy(); } });

  // Touch events
  joyBase.addEventListener('touchstart', e => { e.preventDefault(); setJoyFromCoord(e.touches[0].clientX, e.touches[0].clientY); });
  joyBase.addEventListener('touchmove', e => { e.preventDefault(); setJoyFromCoord(e.touches[0].clientX, e.touches[0].clientY); });
  joyBase.addEventListener('touchend', e => { e.preventDefault(); resetJoy(); });

  // fire button
  fireBtn.addEventListener('click', e => { e.preventDefault(); playerFire(); });
  fireBtn.addEventListener('touchstart', e => { e.preventDefault(); playerFire(); });

  // ---------- Main loop ----------
  let last = performance.now();
  function mainLoop(now){
    const dt = Math.min(0.05, (now - last) / 1000); last = now;

    // movement: keyboard + thumbstick
    const speed = 150 * dt;
    const cos = Math.cos(player.ang), sin = Math.sin(player.ang);

    // keyboard movement (W/S forwards/backwards)
    if (keys['KeyW']) tryMovePlayer(cos * speed, sin * speed);
    if (keys['KeyS']) tryMovePlayer(-cos * speed, -sin * speed);

    // keyboard strafing (A/D)
    if (keys['KeyA']) tryMovePlayer(-sin * speed, cos * speed);
    if (keys['KeyD']) tryMovePlayer(sin * speed, -cos * speed);

    // arrow turning
    if (keys['ArrowLeft']) player.ang -= 2.6 * dt;
    if (keys['ArrowRight']) player.ang += 2.6 * dt;

    // thumbstick movement: map (x,y) of thumb to world move relative to player angle
    if (touchMove.active){
      const jx = touchMove.x, jy = -touchMove.y; // invert Y so up is -1
      const mag = Math.hypot(jx, jy);
      if (mag > 0.08){
        const joyAng = Math.atan2(jy, jx) + player.ang;
        const sp = speed * Math.min(1, mag * 1.2);
        tryMovePlayer(Math.cos(joyAng) * sp, Math.sin(joyAng) * sp);
      }
    }

    // shooting (space)
    if (keys['Space'] && !keys._spacePrev){ playerFire(); }
    keys._spacePrev = !!keys['Space'];

    // reload key handled on keydown

    // update entities
    updateEnemies(dt);
    updateBullets(dt);
    updateParticles(dt);

    // flash fade
    if (flashTimer > 0){ flashTimer -= dt; if (flashTimer <= 0) flashEl.style.background = 'rgba(255,0,0,0)'; }

    // check exit tile (advance level)
    if (isExitTileWorld(player.x, player.y)){ loadLevel(currentLevel + 1); }

    // respawn if dead
    if (player.hp <= 0) loadLevel(currentLevel);

    // render
    renderAll();

    // HUD
    renderFace();
    updateHUD();

    requestAnimationFrame(mainLoop);
  }

  // ---------- Render everything (raycast + sprites + HUD) ----------
  function renderAll(){
    ctx.fillStyle = '#5a5a66'; ctx.fillRect(0,0,W,H/2);
    ctx.fillStyle = '#0d0d0d'; ctx.fillRect(0,H/2,W,H/2);

    const planeDist = (W/2) / Math.tan(HALF_FOV);
    const colW = W / rays;
    const baseCols = ['#9a9a9a','#7c5c3c','#5c7c3c','#5c5c7c'];
    for (let r = 0; r < rays; r++){
      const cameraX = (2 * r / rays) - 1;
      const rayA = player.ang + Math.atan(cameraX * Math.tan(HALF_FOV));
      const res = castSingleRay(player.x, player.y, rayA);
      const corrected = res.dist * Math.cos(rayA - player.ang);
      const h = Math.min(H*2, (TILE * planeDist) / Math.max(0.0001, corrected));
      const drawStart = Math.floor((H/2) - h/2);
      const idx = (Math.floor(r * 0.03) % baseCols.length + baseCols.length) % baseCols.length;
      const shade = Math.max(0.16, 1 - (corrected / 1600));
      ctx.fillStyle = shadeColor(baseCols[idx], shade);
      ctx.fillRect(r * colW, drawStart, colW + 0.9, Math.max(1, Math.floor(h)));
      if (res.hitExit){
        ctx.fillStyle = 'rgba(110,255,120,0.06)'; ctx.fillRect(r*colW, drawStart, colW+0.9, Math.max(1, Math.floor(h)));
      }
    }

    // sprites
    const sprites = [];
    const plane = planeDist;
    for (let e of enemies){
      if (!e.alive) continue;
      const dx = e.x - player.x, dy = e.y - player.y;
      const dist = Math.hypot(dx, dy);
      const angTo = Math.atan2(dy, dx);
      let rel = angTo - player.ang; rel = ((rel + Math.PI) % (2*Math.PI)) - Math.PI;
      if (Math.abs(rel) > HALF_FOV + 0.6) continue;
      if (!hasLineOfSight(player.x, player.y, e.x, e.y)) continue;
      const screenX = (0.5 * (1 + Math.tan(rel) / Math.tan(HALF_FOV))) * W;
      const scale = Math.min(1.8, (TILE * plane) / Math.max(1, dist));
      const size = Math.max(8, scale * 44);
      sprites.push({ e, dist, screenX, size });
    }
    sprites.sort((a,b)=>b.dist - a.dist);
    for (let s of sprites){
      const e = s.e; const x = s.screenX - s.size/2, y = H/2 - s.size/2;
      ctx.fillStyle = '#c33'; ctx.fillRect(x, y, s.size, s.size);
      const pct = Math.max(0, Math.min(1, e.hp / 100));
      ctx.fillStyle = '#0f0'; ctx.fillRect(x, y - 6, s.size * pct, 4);
      ctx.fillStyle = '#330'; ctx.fillRect(x + s.size * pct, y - 6, s.size * (1 - pct), 4);
    }

    // bullets & particles
    for (let b of enemyBullets){ const sx = projectToScreenX(b.x,b.y); if (sx !== null){ ctx.fillStyle='#ffddaa'; ctx.fillRect(sx-2, H/2-2, 4,4); } }
    for (let b of playerBullets){ const sx = projectToScreenX(b.x,b.y); if (sx !== null){ ctx.fillStyle='#ffeeaa'; ctx.fillRect(sx-2, H/2-2, 4,4); } }
    for (let p of particles){ const sx = projectToScreenX(p.x,p.y); if (sx !== null){ const alpha = Math.max(0, p.life / PARTICLE_LIFE); ctx.globalAlpha = alpha; ctx.fillStyle = p.color || '#ffd'; ctx.fillRect(sx - p.size, H/2 - p.size, p.size*2, p.size*2); ctx.globalAlpha = 1; } }

    // crosshair
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(W/2 - 1, H/2 - 12, 2, 24); ctx.fillRect(W/2 - 12, H/2 - 1, 24, 2);

    // minimap
    drawMiniMap();
  }

  // ---------- Start ----------
  function loadLevelStart(){
    loadLevel(0);
    updateHUD();
    requestAnimationFrame(mainLoop);
  }

  loadLevelStart();

  // expose debug
  window.__mini = { player, enemies, LEVELS, loadLevel };

})();
</script>
</body>
</html>
