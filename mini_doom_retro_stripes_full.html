<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini DOOM — Retro Stripes Full</title>
<style>
  html,body{height:100%;margin:0;background:#000;color:#ddd;font-family:system-ui,Segoe UI,Roboto,Arial;overflow:hidden}
  canvas{display:block;width:100vw;height:100vh;touch-action:none;background:#000}
  #hud{position:fixed;left:10px;bottom:12px;z-index:60;background:rgba(0,0,0,0.55);padding:8px 10px;border-radius:8px;font-family:monospace}
  #hud .line{color:#fff;margin:4px 0}
  #flash{pointer-events:none;position:fixed;inset:0;z-index:80;background:rgba(255,0,0,0);transition:background 120ms linear}
  #bigOverlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.88);z-index:9999;opacity:0;pointer-events:none;transition:opacity 220ms}
  #bigOverlay.show{opacity:1;pointer-events:auto}
  #bigOverlay .msg{color:#fff;font-weight:900;font-size:18vw;text-align:center}
  #touchLeft,#touchRight{position:fixed;bottom:18px;z-index:70}
  #touchLeft{left:18px;width:140px;height:140px}
  #touchRight{right:18px;width:140px;height:140px;display:flex;align-items:center;justify-content:center}
  .joyBase{width:100%;height:100%;border-radius:50%;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;cursor:grab}
  .joyThumb{width:44px;height:44px;border-radius:50%;background:rgba(255,255,255,0.12);transform:translate(0,0)}
  .fireBtn{width:84px;height:84px;border-radius:50%;background:linear-gradient(180deg,#ff6a4a,#d24022);display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700;cursor:pointer}
  #minimap{position:fixed;right:10px;top:10px;border:3px solid rgba(255,255,255,0.06);z-index:70;background:rgba(0,0,0,0.5)}
  .smallNote{position:fixed;right:10px;bottom:110px;background:rgba(0,0,0,0.45);padding:8px;border-radius:8px;font-size:12px;z-index:70}
</style>
</head>
<body>
<canvas id="world"></canvas>

<div id="hud">
  <div class="line">HEALTH: <span id="hp">100</span></div>
  <div class="line">AMMO: <span id="ammo">0</span> <button id="reloadBtn">R</button> <button id="nextBtn">L</button></div>
  <div class="line" id="levelLabel">Level: 1</div>
</div>

<canvas id="minimap" width="160" height="160"></canvas>

<div id="flash"></div>
<div id="bigOverlay" aria-hidden="true"><div class="msg" id="bigText">hi Darren</div></div>

<div id="touchLeft"><div class="joyBase" id="joyBase"><div class="joyThumb" id="joyThumb"></div></div></div>
<div id="touchRight"><div class="fireBtn" id="fireBtn">FIRE</div></div>
<div class="smallNote">Controls: WASD move · A/D strafe · Click to lock mouse · Space shoot · R reload · L next level · M toggle maps · K lava mode</div>

<script>
(() => {
  // ---------- Config ----------
  const TILE = 64;
  const FOV = Math.PI/3, HALF_FOV = FOV/2;
  const BASE_RAYS = 280, MOBILE_RAYS = 120;
  const MAX_AMMO = 12, RELOAD_MS = 900;
  const PARTICLE_LIFE = 0.45, PARTICLE_PER_IMPACT = 8;

  // ---------- Level data (10) ----------
  // '.' floor, '#' wall, '>' exit, '~' lava
  const LEVELS = [
`################
#..............#
#..##....##....#
#..##....##....#
#..............#
#..####..####..#
#..#........#..#
#..#..##....#..#
#..#..##....#..#
#..#........#..#
#..####..####..#
#..............#
#.....##.....>.#
#..............#
#..............#
################`, // 1
`################
#....#.....>...#
#..##.#..##....#
#..##.#..##....#
#....#.....#...#
#..####..####..#
#..#........#..#
#..#..##....#..#
#..#..##....#..#
#..#........#..#
#..####..####..#
#..............#
#.....##.......#
#..............#
#..............#
################`, //2
`################
#.....>........#
#..######......#
#..#....#......#
#..#....#..##..#
#..#....#..##..#
#..#....#......#
#..######......#
#..............#
#..##....##....#
#..##....##....#
#..............#
#..............#
#..............#
#..............#
################`, //3
`################
#>.............#
#..####..####..#
#..#........#..#
#..#..##....#..#
#..#..##....#..#
#..#........#..#
#..####..####..#
#..............#
#..##....##....#
#..##....##....#
#..............#
#..............#
#..............#
#..............#
################`, //4
`################
#......>.......#
#..............#
#..............#
#....##....##..#
#....##....##..#
#..............#
#..##########..#
#..#........#..#
#..#..##....#..#
#..#..##....#..#
#..#........#..#
#..##########..#
#..............#
#..............#
################`, //5
`################
#...........>..#
#..######......#
#..#....#......#
#..#....#..##..#
#..#....#..##..#
#..#....#......#
#..######......#
#..............#
#..##....##....#
#..##....##....#
#..............#
#..............#
#..............#
#..............#
################`, //6
`################
#......>.......#
#..######......#
#..#....#......#
#..#..~~#..##..#
#..#..~~#..##..#
#..#....#......#
#..######......#
#..............#
#..##....##....#
#..##....##....#
#..............#
#..............#
#..............#
#..............#
################`, //7 (lava)
`################
#..>...........#
#..##.####.##..#
#..##.#..#.#...#
#..##.#..#.#...#
#..##.####.##..#
#..............#
#..##########..#
#..#........#..#
#..#..##....#..#
#..#..##....#..#
#..#........#..#
#..##########..#
#..............#
#..............#
################`, //8
`################
#..>...........#
#..............#
#..............#
#....##....##..#
#....##....##..#
#..............#
#..##########..#
#..#........#..#
#..#..##....#..#
#..#..##....#..#
#..#........#..#
#..##########..#
#..............#
#..............#
################`, //9
`################
#..............#
#..######..>...#
#..#....#......#
#..#....#..##..#
#..#....#..##..#
#..#....#......#
#..######......#
#..............#
#..##....##....#
#..##....##....#
#..............#
#..............#
#..............#
#..............#
################` //10
  ].map(s => s.split('\n'));

  // ---------- Canvas setup ----------
  const canvas = document.getElementById('world');
  const ctx = canvas.getContext('2d', { alpha:false });
  let W = innerWidth, H = innerHeight, dpr = Math.max(1, devicePixelRatio || 1);
  function resize(){ W = innerWidth; H = innerHeight; canvas.style.width = W+'px'; canvas.style.height = H+'px'; canvas.width = Math.floor(W*dpr); canvas.height = Math.floor(H*dpr); ctx.setTransform(dpr,0,0,dpr,0,0); }
  window.addEventListener('resize', resize);
  resize();

  // ---------- HUD + UI ----------
  const hpEl = document.getElementById('hp'), ammoEl = document.getElementById('ammo'), levelLabel = document.getElementById('levelLabel');
  document.getElementById('reloadBtn').addEventListener('click', startReload);
  document.getElementById('nextBtn').addEventListener('click', ()=> loadLevel(current + 1));
  const flashEl = document.getElementById('flash'), bigOverlay = document.getElementById('bigOverlay'), bigText = document.getElementById('bigText');
  const minimapCanvas = document.getElementById('minimap'), mctx = minimapCanvas.getContext('2d');

  // thumbstick UI
  const joyBase = document.getElementById('joyBase'), joyThumb = document.getElementById('joyThumb'), fireBtn = document.getElementById('fireBtn');

  // ---------- State ----------
  let current = 0;
  let MAP = [], MAP_W = 0, MAP_H = 0;
  const player = { x: TILE*3.5, y: TILE*3.5, ang: 0.6, hp: 100, ammo: MAX_AMMO, reloading: false, moving: false, bob:0 };
  let enemies = [];
  const enemyBullets = [], playerBullets = [], particles = [];

  let instantKillLava = false;
  let rays = BASE_RAYS;

  // ---------- Utilities ----------
  function loadMap(idx){
    current = ((idx % LEVELS.length) + LEVELS.length) % LEVELS.length;
    MAP = LEVELS[current].map.map(row => row.split(''));
    MAP_W = MAP[0].length; MAP_H = MAP.length;
    // find safe spawn tile: try center area first, else scan
    const spawn = findSafeSpawn();
    player.x = spawn.x; player.y = spawn.y; player.ang = 0.6;
    player.hp = 100; player.ammo = MAX_AMMO; player.reloading = false; player.moving = false; player.bob = 0;
    // create simple enemies on map open spots (not too many)
    enemies = [];
    for (let y=1;y<MAP_H-1;y++) for (let x=1;x<MAP_W-1;x++){
      if (MAP[y][x] === '.' && Math.random() < 0.02) enemies.push({ x:(x+0.5)*TILE, y:(y+0.5)*TILE, hp:60 + Math.floor(Math.random()*40), alive:true, shootCooldown: Math.random()*2 });
    }
    enemyBullets.length = 0; playerBullets.length = 0; particles.length = 0;
    updateHud();
  }

  function findSafeSpawn(){
    // try near center of map, else find any '.' with 4-way clearance
    const centerX = Math.floor(MAP_W/2), centerY = Math.floor(MAP_H/2);
    const tryCoords = [
      [centerX, centerY],
      [Math.floor(MAP_W/3), Math.floor(MAP_H/3)],
      [Math.floor(MAP_W*2/3), Math.floor(MAP_H/3)],
      [Math.floor(MAP_W/3), Math.floor(MAP_H*2/3)]
    ];
    for (let [sx,sy] of tryCoords){
      if (safeTile(sx,sy)) return { x:(sx+0.5)*TILE, y:(sy+0.5)*TILE };
    }
    for (let y=1;y<MAP_H-1;y++){
      for (let x=1;x<MAP_W-1;x++){
        if (safeTile(x,y)) return { x:(x+0.5)*TILE, y:(y+0.5)*TILE };
      }
    }
    // fallback center
    return { x:(centerX+0.5)*TILE, y:(centerY+0.5)*TILE };
  }
  function safeTile(x,y){
    if (MAP[y][x] !== '.' && MAP[y][x] !== '>') return false;
    return MAP[y-1][x] !== '#' && MAP[y+1][x] !== '#' && MAP[y][x-1] !== '#' && MAP[y][x+1] !== '#';
  }

  function mapAt(mx,my){ if (mx<0||my<0||mx>=MAP_W||my>=MAP_H) return '#'; return MAP[my][mx]; }
  function isWallWorld(x,y){ const mx = Math.floor(x/TILE), my = Math.floor(y/TILE); if (mx<0||my<0||mx>=MAP_W||my>=MAP_H) return true; return MAP[my][mx] === '#'; }
  function isLavaWorld(x,y){ const mx = Math.floor(x/TILE), my = Math.floor(y/TILE); if (mx<0||my<0||mx>=MAP_W||my>=MAP_H) return false; return MAP[my][mx] === '~'; }
  function isExitWorld(x,y){ const mx = Math.floor(x/TILE), my = Math.floor(y/TILE); if (mx<0||my<0||mx>=MAP_W||my>=MAP_H) return false; return MAP[my][mx] === '>'; }

  // ---------- Particles & flash ----------
  let flashTimer = 0;
  function triggerFlash(){ flashTimer = 0.16; flashEl.style.background = 'rgba(255,0,0,0.35)'; }
  function spawnImpact(x,y,angle,color){
    for (let i=0;i<PARTICLE_PER_IMPACT;i++){
      const a = angle + (Math.random()-0.5)*Math.PI*0.7;
      const sp = 80 + Math.random()*260;
      particles.push({ x,y,vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life: PARTICLE_LIFE*(0.6 + Math.random()*0.9), color, size:1 + Math.random()*2 });
    }
  }
  function updateParticles(dt){
    for (let i=particles.length-1;i>=0;i--){
      const p = particles[i]; p.life -= dt;
      if (p.life <= 0) particles.splice(i,1);
      else { p.x += p.vx * dt; p.y += p.vy * dt; p.vx *= 0.96; p.vy *= 0.96; }
    }
  }

  // ---------- Shooting & reload ----------
  let reloadAt = 0;
  function startReload(){ if (player.reloading) return; player.reloading = true; reloadAt = performance.now() + RELOAD_MS; setTimeout(()=>{ player.ammo = MAX_AMMO; player.reloading = false; updateHud(); }, RELOAD_MS); updateHud(); }
  function playerFire(){
    if (player.reloading) return;
    if (player.ammo <= 0){ startReload(); return; }
    player.ammo--;
    const angle = player.ang + (Math.random()-0.5)*0.006;
    playerBullets.push({ x: player.x + Math.cos(angle)*18, y: player.y + Math.sin(angle)*18, vx: Math.cos(angle)*1100, vy: Math.sin(angle)*1100, life: 0.7 });
    // immediate hit-check (simple): damage first enemy in cone
    for (let e of enemies){ if (!e.alive) continue;
      const dx = e.x - player.x, dy = e.y - player.y; const d = Math.hypot(dx,dy); const a2 = Math.atan2(dy,dx); let rel = a2 - angle; rel = ((rel + Math.PI)%(2*Math.PI)) - Math.PI;
      if (Math.abs(rel) < 0.25 && d < 900){
        e.hp -= 38; spawnImpact(e.x, e.y, a2, '#ffb3b3'); if (e.hp <= 0) e.alive = false; break;
      }
    }
    updateHud();
  }

  function fireEnemyBullet(enemy, angle){
    const spread = (Math.random()-0.5)*0.14; const a = angle + spread;
    enemyBullets.push({ x: enemy.x + Math.cos(a)*18, y: enemy.y + Math.sin(a)*18, vx: Math.cos(a)*(360 + Math.random()*120), vy: Math.sin(a)*(360 + Math.random()*120), life: 3.0, dmg: 10 });
  }

  // ---------- Enemies & bullets ----------
  function updateEnemies(dt){
    for (let e of enemies){
      if (!e.alive) continue;
      const dx = player.x - e.x, dy = player.y - e.y; const d = Math.hypot(dx,dy), angTo = Math.atan2(dy,dx);
      if (d > 60){
        const sp = 36 + Math.random()*22;
        const nx = Math.cos(angTo)*sp*dt, ny = Math.sin(angTo)*sp*dt;
        if (!isWallWorld(e.x + nx, e.y + ny)){ e.x += nx; e.y += ny; }
      } else {
        player.hp -= 18 * dt; if (player.hp < 0) player.hp = 0; triggerFlash();
      }
      e.shootCooldown = e.shootCooldown || 0; e.shootCooldown -= dt;
      if (d < 700 && e.shootCooldown <= 0 && lineOfSight(e.x,e.y,player.x,player.y)){ fireEnemyBullet(e, angTo); e.shootCooldown = 1.2 + Math.random()*1.6; }
    }
  }

  function updateBullets(dt){
    for (let i=enemyBullets.length-1;i>=0;i--){
      const b = enemyBullets[i]; b.life -= dt; b.x += b.vx*dt; b.y += b.vy*dt;
      if (b.life <= 0 || isWallWorld(b.x,b.y)){ spawnImpact(b.x,b.y, Math.atan2(b.vy,b.vx), '#ffd3a6'); enemyBullets.splice(i,1); continue; }
      if (Math.hypot(b.x-player.x,b.y-player.y) < 16){ player.hp -= b.dmg; if (player.hp < 0) player.hp = 0; spawnImpact(b.x,b.y, Math.atan2(b.y-player.y,b.x-player.x), '#ff8b8b'); triggerFlash(); enemyBullets.splice(i,1); continue; }
    }
    for (let i=playerBullets.length-1;i>=0;i--){
      const b = playerBullets[i]; b.life -= dt; b.x += b.vx*dt; b.y += b.vy*dt;
      if (b.life <= 0 || isWallWorld(b.x,b.y)){ spawnImpact(b.x,b.y, Math.atan2(b.vy,b.vx), '#ffd'); playerBullets.splice(i,1); continue; }
      for (let e of enemies){ if (!e.alive) continue; if (Math.hypot(b.x-e.x,b.y-e.y) < 18){ e.hp -= 36; spawnImpact(b.x,b.y, Math.atan2(b.y-e.y,b.x-e.x),'#ffb3b3'); if (e.hp <= 0) e.alive = false; playerBullets.splice(i,1); break; } }
    }
  }

  // ---------- Movement (buffer to avoid wall clipping) ----------
  function tryMove(dx,dy){
    const nx = player.x + dx, ny = player.y + dy;
    const r = 14;
    function blocked(px,py){
      return isWallWorld(px - r, py) || isWallWorld(px + r, py) || isWallWorld(px, py - r) || isWallWorld(px, py + r);
    }
    if (!blocked(nx, player.y)) player.x = nx;
    if (!blocked(player.x, ny)) player.y = ny;
    // lava
    if (isLavaWorld(player.x, player.y)){
      player.hp -= instantKillLava ? 9999 : 40 * (1/60);
      if (player.hp < 0) player.hp = 0;
      triggerFlash();
    }
  }

  // ---------- Raycast (retro striped walls) ----------
  function castRay(ox,oy,angle){
    let a = angle % (Math.PI*2); if (a < 0) a += Math.PI*2;
    const sin = Math.sin(a), cos = Math.cos(a);
    let mapX = Math.floor(ox/TILE), mapY = Math.floor(oy/TILE);
    const deltaDistX = Math.abs(1/(cos||1e-6)), deltaDistY = Math.abs(1/(sin||1e-6));
    let stepX, stepY, sideDistX, sideDistY;
    if (cos < 0){ stepX = -1; sideDistX = (ox - mapX*TILE) * deltaDistX / TILE; } else { stepX = 1; sideDistX = ((mapX+1)*TILE - ox) * deltaDistX / TILE; }
    if (sin < 0){ stepY = -1; sideDistY = (oy - mapY*TILE) * deltaDistY / TILE; } else { stepY = 1; sideDistY = ((mapY+1)*TILE - oy) * deltaDistY / TILE; }
    let hit=false, side=0, safety=0, hitExit=false, hitX=ox, hitY=oy;
    while(!hit && safety++ < 4096){
      if (sideDistX < sideDistY){ sideDistX += deltaDistX / TILE; mapX += stepX; side = 0; } else { sideDistY += deltaDistY / TILE; mapY += stepY; side = 1; }
      const c = mapAt(mapX, mapY);
      if (c === '#') hit = true;
      if (c === '>') hitExit = true;
      if (c === '~') { /* keep searching — lava is walkable */ }
    }
    if (!hit) return { dist: 1e6, hitExit };
    if (side === 0){ const xHit = mapX*TILE + (stepX === -1 ? TILE : 0); const t = (xHit - ox) / (cos || 1e-6); hitX = ox + cos*t; hitY = oy + sin*t; perpDist = Math.abs((hitX - ox) / (cos || 1e-6)); }
    else { const yHit = mapY*TILE + (stepY === -1 ? TILE : 0); const t = (yHit - oy) / (sin || 1e-6); hitX = ox + cos*t; hitY = oy + sin*t; perpDist = Math.abs((hitY - oy) / (sin || 1e-6)); }
    return { dist: perpDist, hitX, hitY, side, hitExit };
  }

  function screenXForWorld(wx,wy){
    const dx = wx - player.x, dy = wy - player.y;
    const ang = Math.atan2(dy,dx);
    let rel = ang - player.ang; rel = ((rel + Math.PI)%(2*Math.PI)) - Math.PI;
    if (Math.abs(rel) > HALF_FOV + 0.6) return null;
    return (0.5 * (1 + Math.tan(rel) / Math.tan(HALF_FOV))) * W;
  }

  // ---------- Minimap (like test) ----------
  function drawMinimap(){
    const s = minimapCanvas.width / MAP_W;
    mctx.clearRect(0,0,minimapCanvas.width,minimapCanvas.height);
    for (let y=0;y<MAP_H;y++){
      for (let x=0;x<MAP_W;x++){
        const c = MAP[y][x];
        if (c === '#') mctx.fillStyle = '#999';
        else if (c === '~') mctx.fillStyle = '#ff6a2b';
        else if (c === '>') mctx.fillStyle = '#7bff7b';
        else mctx.fillStyle = '#111';
        mctx.fillRect(x*s, y*s, s, s);
      }
    }
    for (let e of enemies) if (e.alive){ mctx.fillStyle = '#f55'; mctx.beginPath(); mctx.arc(e.x / TILE * s, e.y / TILE * s, 3, 0, Math.PI*2); mctx.fill(); }
    mctx.fillStyle = '#ff0'; mctx.beginPath(); mctx.arc(player.x / TILE * s, player.y / TILE * s, 4, 0, Math.PI*2); mctx.fill();
    mctx.strokeStyle = '#ff0'; mctx.beginPath(); mctx.moveTo(player.x / TILE * s, player.y / TILE * s); mctx.lineTo(player.x / TILE * s + Math.cos(player.ang)*8, player.y / TILE * s + Math.sin(player.ang)*8); mctx.stroke();
  }

  // ---------- HUD ----------
  function updateHud(){ hpEl.textContent = Math.max(0, Math.round(player.hp)); ammoEl.textContent = player.reloading ? 'Reloading...' : `${player.ammo} / ${MAX_AMMO}`; levelLabel.textContent = `Level: ${current+1}`; }

  // ---------- Input ----------
  const keys = {};
  window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault();
    if (e.code === 'KeyR') startReload();
    if (e.code === 'KeyL') loadMap(current+1);
    if (e.code === 'KeyM'){ /* not used */ }
    if (e.code === 'KeyK') instantKillLava = !instantKillLava;
  });
  window.addEventListener('keyup', e => keys[e.code] = false);

  canvas.addEventListener('click', ()=> { if (document.pointerLockElement !== canvas) canvas.requestPointerLock(); });
  window.addEventListener('mousemove', e => { if (document.pointerLockElement === canvas) player.ang += e.movementX * 0.0026; });
  canvas.addEventListener('mousedown', e => { if (e.button === 0) playerFire(); });

  // thumbstick handling
  let touchMove = { x:0, y:0, active:false };
  function setJoy(clientX, clientY){
    const r = joyBase.getBoundingClientRect(); const cx = r.left + r.width/2, cy = r.top + r.height/2;
    let dx = (clientX - cx) / (r.width/2), dy = (clientY - cy) / (r.height/2);
    dx = Math.max(-1, Math.min(1, dx)); dy = Math.max(-1, Math.min(1, dy));
    joyThumb.style.transform = `translate(${dx*36}px,${dy*36}px)`; touchMove.x = dx; touchMove.y = dy; touchMove.active = true;
  }
  function resetJoy(){ joyThumb.style.transform = 'translate(0,0)'; touchMove.active = false; touchMove.x = 0; touchMove.y = 0; }
  let joyDown = false;
  joyBase.addEventListener('mousedown', e => { e.preventDefault(); joyDown = true; setJoy(e.clientX, e.clientY); });
  window.addEventListener('mousemove', e => { if (joyDown) setJoy(e.clientX, e.clientY); });
  window.addEventListener('mouseup', e => { if (joyDown){ joyDown = false; resetJoy(); } });
  joyBase.addEventListener('touchstart', e => { e.preventDefault(); setJoy(e.touches[0].clientX, e.touches[0].clientY); });
  joyBase.addEventListener('touchmove', e => { e.preventDefault(); setJoy(e.touches[0].clientX, e.touches[0].clientY); });
  joyBase.addEventListener('touchend', e => { e.preventDefault(); resetJoy(); });
  fireBtn.addEventListener('click', e => { e.preventDefault(); playerFire(); });
  fireBtn.addEventListener('touchstart', e => { e.preventDefault(); playerFire(); });

  // ---------- Render loop (retro stripes) ----------
  function render(){
    // ceiling & floor
    ctx.fillStyle = '#6b6b73'; ctx.fillRect(0,0,W,H/2);
    ctx.fillStyle = '#0b0b0b'; ctx.fillRect(0,H/2,W,H/2);

    rays = (navigator.maxTouchPoints && navigator.maxTouchPoints>0) ? MOBILE_RAYS : Math.max(160, Math.floor(BASE_RAYS * Math.min(1, W/1280)));
    const colW = W / rays;
    const planeDist = (W/2) / Math.tan(HALF_FOV);

    for (let r=0;r<rays;r++){
      const cameraX = (2*r/rays) - 1;
      const rayA = player.ang + Math.atan(cameraX * Math.tan(HALF_FOV));
      const res = castRay(player.x, player.y, rayA);
      const corrected = res.dist * Math.cos(rayA - player.ang);
      const wallH = Math.min(H*2, (TILE * planeDist) / Math.max(0.0001, corrected));
      const drawStart = Math.floor((H/2) - wallH/2);

      // retro stripe pattern: choose color by column offset
      // draw column rectangle and then darken by distance
      const stripes = 5; // stripe frequency
      const stripeColorA = '#777';
      const stripeColorB = '#555';
      // draw vertical faux-stripes by filling the rect with alternating thin bars
      const x = r*colW;
      ctx.save();
      for (let sx = 0; sx < colW+1; sx++){
        const t = Math.floor((sx + (r%stripes)) / 3) % 2;
        ctx.fillStyle = (t === 0) ? stripeColorA : stripeColorB;
        ctx.fillRect(x + sx, drawStart, 1, Math.max(1, Math.floor(wallH)));
      }
      // shading overlay
      const shade = Math.max(0.12, 1 - (corrected / 1600));
      ctx.globalCompositeOperation = 'multiply';
      ctx.fillStyle = `rgba(0,0,0,${1 - shade})`;
      ctx.fillRect(x, drawStart, colW+1, Math.max(1, Math.floor(wallH)));
      ctx.globalCompositeOperation = 'source-over';
      // exit tint
      if (res.hitExit){ ctx.fillStyle = 'rgba(120,255,140,0.06)'; ctx.fillRect(x, drawStart, colW+1, Math.max(1, Math.floor(wallH))); }
      ctx.restore();
    }

    // draw enemies (simple sprites)
    const sprites = [];
    for (let e of enemies){ if (!e.alive) continue;
      const dx = e.x - player.x, dy = e.y - player.y, angTo = Math.atan2(dy,dx), dist = Math.hypot(dx,dy);
      let rel = angTo - player.ang; rel = ((rel + Math.PI)%(2*Math.PI)) - Math.PI;
      if (Math.abs(rel) > HALF_FOV + 0.6) continue;
      if (!lineOfSight(player.x,player.y,e.x,e.y)) continue;
      const screenX = (0.5*(1 + Math.tan(rel)/Math.tan(HALF_FOV)))*W;
      const scale = Math.min(1.8, (TILE * planeDist) / Math.max(1, dist));
      const size = Math.max(8, scale * 44);
      sprites.push({ e, dist, screenX, size });
    }
    sprites.sort((a,b)=>b.dist - a.dist);
    for (let s of sprites){
      const e = s.e; const x = s.screenX - s.size/2, y = H/2 - s.size/2;
      ctx.fillStyle = '#c33'; ctx.fillRect(x,y,s.size,s.size);
      const pct = Math.max(0, Math.min(1, e.hp/100));
      ctx.fillStyle = '#0f0'; ctx.fillRect(x, y-6, s.size*pct, 4);
    }

    // bullets & particles
    for (let b of enemyBullets){ const sx = screenXForWorld(b.x,b.y); if (sx!==null){ ctx.fillStyle = '#ffddaa'; ctx.fillRect(sx-2, H/2-2, 4,4); } }
    for (let b of playerBullets){ const sx = screenXForWorld(b.x,b.y); if (sx!==null){ ctx.fillStyle = '#ffeeaa'; ctx.fillRect(sx-2, H/2-2, 4,4); } }
    for (let p of particles){ const sx = screenXForWorld(p.x,p.y); if (sx!==null){ const alpha = Math.max(0, p.life / PARTICLE_LIFE); ctx.globalAlpha = alpha; ctx.fillStyle = p.color || '#ffd'; ctx.fillRect(sx - p.size, H/2 - p.size, p.size*2, p.size*2); ctx.globalAlpha = 1; } }

    // crosshair
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(W/2 - 1, H/2 - 12, 2, 24); ctx.fillRect(W/2 - 12, H/2 - 1, 24, 2);

    // minimap
    drawMinimap();
  }

  // ---------- Line-of-sight (ray stepping) ----------
  function lineOfSight(x0,y0,x1,y1){
    const ang = Math.atan2(y1-y0,x1-x0), sin = Math.sin(ang), cos = Math.cos(ang);
    let d = 0;
    while (d < 4000){
      d += 8;
      const px = x0 + cos*d, py = y0 + sin*d;
      if (isWallWorld(px,py)) return false;
      if (Math.hypot(px-x1,py-y1) < 8) return true;
    }
    return false;
  }

  // ---------- Main loop ----------
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.05, (now - last)/1000); last = now;

    // movement
    const speed = 150 * dt;
    const cos = Math.cos(player.ang), sin = Math.sin(player.ang);
    let moving = false;
    if (keys['KeyW']){ tryMove(cos*speed, sin*speed); moving = true; }
    if (keys['KeyS']){ tryMove(-cos*speed, -sin*speed); moving = true; }
    if (keys['KeyA']){ tryMove(-sin*speed, cos*speed); moving = true; } // strafe left
    if (keys['KeyD']){ tryMove(sin*speed, -cos*speed); moving = true; } // strafe right
    if (keys['ArrowLeft']) player.ang -= 2.6 * dt;
    if (keys['ArrowRight']) player.ang += 2.6 * dt;
    // thumbstick movement
    if (touchMove.active){
      const jx = touchMove.x, jy = -touchMove.y;
      const mag = Math.hypot(jx, jy);
      if (mag > 0.08){
        const joyAng = Math.atan2(jy, jx) + player.ang;
        const sp = speed * Math.min(1, mag * 1.2);
        tryMove(Math.cos(joyAng)*sp, Math.sin(joyAng)*sp);
        moving = true;
      }
    }
    player.moving = moving;
    // fire on space press
    if (keys['Space'] && !keys._spacePrev) playerFire();
    keys._spacePrev = !!keys['Space'];

    // reload complete
    if (player.reloading && performance.now() >= reloadAt){ player.reloading = false; player.ammo = MAX_AMMO; updateHud(); }

    // update enemies, bullets, particles
    updateEnemies(dt); updateBullets(dt); updateParticles(dt);

    // bob
    if (player.moving) player.bob += dt * 9; else player.bob = Math.max(0, player.bob - dt * 8);

    // flash fade
    if (flashTimer > 0){ flashTimer -= dt; if (flashTimer <= 0) flashEl.style.background = 'rgba(255,0,0,0)'; }

    // exit tile check
    if (isExitWorld(player.x, player.y)) loadMap(current + 1);

    // death
    if (player.hp <= 0) loadMap(current);

    // render
    render();

    updateHud();

    requestAnimationFrame(loop);
  }

  // ---------- start & overlay ----------
  setTimeout(()=>{ bigOverlay.classList.add('show'); setTimeout(()=>bigOverlay.classList.remove('show'),3000); }, 10000);

  // ---------- kickoff ----------
  function start(){
    loadMap(0);
    updateHud();
    requestAnimationFrame(loop);
  }
  start();

  // ---------- Expose for debug ----------
  window.__mini = { player, enemies, loadMap, LEVELS };

})();
</script>
</body>
</html>
