<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Mini DOOM — Full Edition (Levels + HUD)</title>
<style>
  :root { --panel: rgba(0,0,0,0.45); --accent: #ffcc22; }
  html,body{height:100%;margin:0;background:#050507;color:#ddd;font-family:system-ui,Segoe UI,Roboto,Arial}
  canvas#world { display:block; width:100vw; height:100vh; background:#000; touch-action:none; }
  /* top UI */
  #topUI { position:fixed; left:10px; top:10px; background:var(--panel); padding:8px 10px; border-radius:8px; z-index:40; font-size:13px; }
  #msg { position:fixed; left:50%; transform:translateX(-50%); top:12px; background:rgba(0,0,0,0.5); padding:8px 12px; border-radius:8px; z-index:40; font-size:13px; }
  /* hit flash overlay */
  #flash { pointer-events:none; position:fixed; left:0; top:0; right:0; bottom:0; z-index:80; background:rgba(255,0,0,0); transition: background 120ms linear; }
  /* minimap corner handled in world canvas drawing */
  /* bottom HUD bar (Doom-like) */
  #hudBar {
    position:fixed; left:0; right:0; bottom:0; height:96px; z-index:60;
    background: linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.85));
    display:flex; align-items:center; padding:8px 14px; box-sizing:border-box;
    gap:18px; border-top:2px solid rgba(255,255,255,0.03);
  }
  #hudFace { width:84px; height:84px; background:#111; border:2px solid #222; border-radius:6px; box-shadow:0 6px 20px rgba(0,0,0,0.6); }
  #hudStats { color:#fff; font-family:monospace; }
  .statLine { font-size:18px; margin-bottom:6px; }
  .statSmall { font-size:13px; color:#bbb; }
  .btnSmall { background:rgba(255,255,255,0.05); padding:6px 8px; border-radius:6px; cursor:pointer; margin-left:8px; color:#fff; }
  /* touch joystick */
  #touchLeft,#touchRight{position:fixed;bottom:18px;z-index:70;display:none}
  #touchLeft{left:18px;width:140px;height:140px}
  #touchRight{right:18px;width:140px;height:140px;display:flex;align-items:center;justify-content:center}
  .joyBase{width:100%;height:100%;border-radius:50%;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center}
  .joyThumb{width:44px;height:44px;border-radius:50%;background:rgba(255,255,255,0.12);transform:translate(0,0)}
  .fireBtn{width:84px;height:84px;border-radius:50%;background:linear-gradient(180deg,#ff6a4a,#d24022);display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700}
</style>
</head>
<body>
  <canvas id="world"></canvas>

  <div id="topUI"><strong>Mini DOOM — Full Edition</strong><div style="font-size:12px">WASD move · A/D strafe · Mouse look (click) · Shoot: LMB/Space · R reload · L next level</div></div>
  <div id="msg">Reach the <strong style="color:#7bff7b">green exit</strong> tile to advance levels.</div>
  <div id="flash"></div>

  <!-- classic bottom HUD -->
  <div id="hudBar">
    <canvas id="hudFace" width="84" height="84"></canvas>
    <div id="hudStats">
      <div class="statLine">HEALTH: <span id="hpText">100</span> <span class="statSmall">/100</span></div>
      <div class="statLine">AMMO: <span id="ammoText">—</span> <span class="statSmall"> (R to reload)</span>
        <button id="btnReload" class="btnSmall">R</button> <button id="btnNext" class="btnSmall">L</button>
      </div>
      <div class="statSmall" id="levelName">Level: 1</div>
    </div>
  </div>

  <!-- touch controls (mobile) -->
  <div id="touchLeft"><div class="joyBase" id="joyBase"><div class="joyThumb" id="joyThumb"></div></div></div>
  <div id="touchRight"><div class="fireBtn" id="fireBtn">FIRE</div></div>

<script>
(() => {
  // ---------- Config ----------
  const TILE = 64;
  const FOV = Math.PI / 3;
  const HALF_FOV = FOV / 2;
  const BASE_RAYS = 300, MOBILE_RAYS = 140;
  const MAX_AMMO = 12, RELOAD_MS = 900;
  const PARTICLE_LIFE = 0.45, PARTICLE_PER_IMPACT = 10;

  // ---------- Level data (pre-made) ----------
  // use '>' in map to mark exit tile (walkable)
  const LEVELS = [
    {
      name: "Training Grounds",
      map: [
"################",
"#..............#",
"#..##....##....#",
"#..##....##....#",
"#..............#",
"#..####..####..#",
"#..#........#..#",
"#..#..##....#..#",
"#..#..##....#..#",
"#..#........#..#",
"#..####..####..#",
"#..............#",
"#.....##.....>.#",
"#..............#",
"#..............#",
"################"
      ],
      spawns: [[8.5,6.5],[12.5,3.5],[6.5,10.5]]
    },
    {
      name: "Factory Maze",
      map: [
"################",
"#....#.....>...#",
"#..##.#..##....#",
"#..##.#..##....#",
"#....#.....#...#",
"#..####..####..#",
"#..#........#..#",
"#..#..##....#..#",
"#..#..##....#..#",
"#..#........#..#",
"#..####..####..#",
"#..............#",
"#.....##.......#",
"#..............#",
"#..............#",
"################"
      ],
      spawns: [[7.5,8.5],[10.5,5.5],[11.5,11.5],[5.5,3.5]]
    }
  ];

  // ---------- Canvas & rendering setup ----------
  const canvas = document.getElementById('world');
  const ctx = canvas.getContext('2d', {alpha:false});
  let W=innerWidth, H=innerHeight;
  let dpr = Math.max(1, window.devicePixelRatio || 1);
  let rays = BASE_RAYS;
  function resize(){
    W = innerWidth; H = innerHeight;
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    canvas.width = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    if (isMobile()) rays = MOBILE_RAYS;
    else rays = Math.max(180, Math.floor(BASE_RAYS * Math.min(1, W / 1280)));
  }
  window.addEventListener('resize', resize);
  resize();

  // ---------- UI elements ----------
  const flashEl = document.getElementById('flash');
  const hudFace = document.getElementById('hudFace');
  const faceCtx = hudFace.getContext('2d');
  const hpText = document.getElementById('hpText');
  const ammoText = document.getElementById('ammoText');
  const levelNameEl = document.getElementById('levelName');
  document.getElementById('btnReload').addEventListener('click', ()=> startReload());
  document.getElementById('btnNext').addEventListener('click', ()=> loadLevel(currentLevel + 1));

  // touch elements
  const touchLeft = document.getElementById('touchLeft');
  const touchRight = document.getElementById('touchRight');
  const joyBase = document.getElementById('joyBase'), joyThumb = document.getElementById('joyThumb');
  const fireBtn = document.getElementById('fireBtn');

  function isMobile(){
    return navigator.maxTouchPoints && navigator.maxTouchPoints > 0 || /Mobi|Android/i.test(navigator.userAgent);
  }
  if (isMobile()){ touchLeft.style.display = 'block'; touchRight.style.display = 'block'; resize(); }

  // ---------- State ----------
  let currentLevel = 0;
  let MAP = LEVELS[currentLevel].map;
  let MAP_W = MAP[0].length, MAP_H = MAP.length;

  const player = {
    x: TILE * 3.5,
    y: TILE * 3.5,
    ang: 0.6,
    hp: 100,
    ammo: MAX_AMMO,
    reloading: false
  };

  let enemies = [];
  function spawnEnemies(list){
    enemies = [];
    for (let s of list) enemies.push({ x: s[0]*TILE, y: s[1]*TILE, hp: 60 + Math.floor(Math.random()*40), alive: true, shootCooldown: 0 });
  }

  // spawn initial
  spawnEnemies(LEVELS[0].spawns);

  // bullets & particles
  const enemyBullets = [];
  const playerBullets = [];
  const particles = [];

  // ---------- Helpers (map & LOS) ----------
  function mapAt(mx,my){
    if (mx < 0 || my < 0 || my >= MAP_H || mx >= MAP_W) return '#';
    return MAP[my][mx];
  }
  function isWallAtWorld(x,y){
    const mx = Math.floor(x/TILE), my = Math.floor(y/TILE);
    if (mx<0||my<0||mx>=MAP_W||my>=MAP_H) return true;
    return MAP[my][mx] === '#';
  }
  // Exit tile check: char '>' denotes exit tile (walkable)
  function isExitTileWorld(x,y){
    const mx = Math.floor(x/TILE), my = Math.floor(y/TILE);
    if (mx<0||my<0||mx>=MAP_W||my>=MAP_H) return false;
    return MAP[my][mx] === '>';
  }

  function hasLineOfSight(x0,y0,x1,y1){
    const ang = Math.atan2(y1-y0, x1-x0);
    const sin = Math.sin(ang), cos = Math.cos(ang);
    let dist = 0;
    while (dist < 4000){
      dist += 8;
      const px = x0 + cos*dist, py = y0 + sin*dist;
      if (isWallAtWorld(px, py)) return false;
      if (Math.hypot(px - x1, py - y1) < 8) return true;
    }
    return false;
  }

  // ---------- Hit flash ----------
  let flashTimer = 0;
  function triggerHitFlash(){
    flashTimer = 0.16;
    flashEl.style.background = 'rgba(255,0,0,0.35)';
  }

  // ---------- Particles ----------
  function spawnImpact(x, y, angle, color){
    for (let i=0;i<PARTICLE_PER_IMPACT;i++){
      const a = angle + (Math.random()-0.5)*Math.PI*0.6;
      const speed = 100 + Math.random()*240;
      particles.push({ x, y, vx: Math.cos(a)*speed, vy: Math.sin(a)*speed, life: PARTICLE_LIFE * (0.6 + Math.random()*0.8), color, size: 1 + Math.random()*2 });
    }
  }
  function updateParticles(dt){
    for (let i = particles.length-1; i >= 0; i--){
      const p = particles[i];
      p.life -= dt;
      if (p.life <= 0){ particles.splice(i,1); continue; }
      p.x += p.vx * dt; p.y += p.vy * dt;
      p.vx *= 0.96; p.vy *= 0.96;
    }
  }

  // ---------- Shooting / reload ----------
  let reloadEndAt = 0;
  function startReload(){
    if (player.reloading) return;
    player.reloading = true;
    reloadEndAt = performance.now() + RELOAD_MS;
    setTimeout(()=>{
      player.ammo = MAX_AMMO;
      player.reloading = false;
      updateHUD();
    }, RELOAD_MS);
    updateHUD();
  }

  function playerFire(){
    if (player.reloading) return;
    if (player.ammo <= 0){ startReload(); return; }
    player.ammo--;
    // visual projectile
    const angle = player.ang + (Math.random()-0.5)*0.004;
    playerBullets.push({ x: player.x + Math.cos(angle)*16, y: player.y + Math.sin(angle)*16, vx: Math.cos(angle)*1100, vy: Math.sin(angle)*1100, life: 0.7 });
    // hitscan
    for (let e of enemies){
      if (!e.alive) continue;
      const dx = e.x - player.x, dy = e.y - player.y;
      const d = Math.hypot(dx,dy);
      const angTo = Math.atan2(dy,dx);
      let rel = angTo - angle; rel = ((rel + Math.PI) % (2*Math.PI)) - Math.PI;
      if (Math.abs(rel) < 0.25 && d < 900 && hasLineOfSight(player.x, player.y, e.x, e.y)){
        e.hp -= 38;
        spawnImpact(e.x, e.y, angTo, '#ffb3b3');
        if (e.hp <= 0) e.alive = false;
        break;
      }
    }
    updateHUD();
  }

  function fireEnemyBullet(enemy, angle){
    const spread = (Math.random()-0.5) * 0.14;
    const a = angle + spread;
    enemyBullets.push({ x: enemy.x + Math.cos(a)*18, y: enemy.y + Math.sin(a)*18, vx: Math.cos(a)*(360+Math.random()*120), vy: Math.sin(a)*(360+Math.random()*120), life: 3.0, dmg: 10 });
  }

  // ---------- Update enemies & bullets ----------
  function updateEnemies(dt){
    for (let e of enemies){
      if (!e.alive) continue;
      const dx = player.x - e.x, dy = player.y - e.y;
      const d = Math.hypot(dx,dy);
      const angTo = Math.atan2(dy,dx);
      // movement
      if (d > 60){
        const speed = 36 + Math.random()*22;
        const nx = Math.cos(angTo)*speed*dt, ny = Math.sin(angTo)*speed*dt;
        if (!isWallAtWorld(e.x + nx, e.y + ny)){ e.x += nx; e.y += ny; }
      } else {
        player.hp -= 18 * dt;
        if (player.hp < 0) player.hp = 0;
        triggerHitFlash();
      }
      // shooting
      e.shootCooldown = e.shootCooldown || 0; e.shootCooldown -= dt;
      if (d < 700 && e.shootCooldown <= 0 && hasLineOfSight(e.x, e.y, player.x, player.y)){
        fireEnemyBullet(e, angTo);
        e.shootCooldown = 1.2 + Math.random()*1.6;
      }
    }
  }

  function updateBullets(dt){
    // enemy bullets
    for (let i = enemyBullets.length-1; i >= 0; i--){
      const b = enemyBullets[i];
      b.life -= dt;
      b.x += b.vx * dt; b.y += b.vy * dt;
      if (b.life <= 0 || isWallAtWorld(b.x, b.y)){
        spawnImpact(b.x, b.y, Math.atan2(b.vy, b.vx), '#ffd3a6');
        enemyBullets.splice(i,1); continue;
      }
      if (Math.hypot(b.x - player.x, b.y - player.y) < 16){
        player.hp -= b.dmg; if (player.hp < 0) player.hp = 0;
        spawnImpact(b.x, b.y, Math.atan2(b.y - player.y, b.x - player.x), '#ff8b8b');
        triggerHitFlash();
        enemyBullets.splice(i,1); continue;
      }
    }
    // player bullets
    for (let i = playerBullets.length-1; i >= 0; i--){
      const b = playerBullets[i];
      b.life -= dt;
      b.x += b.vx * dt; b.y += b.vy * dt;
      if (b.life <= 0 || isWallAtWorld(b.x, b.y)){
        spawnImpact(b.x, b.y, Math.atan2(b.vy, b.vx), '#ffd');
        playerBullets.splice(i,1); continue;
      }
      for (let e of enemies){
        if (!e.alive) continue;
        if (Math.hypot(b.x - e.x, b.y - e.y) < 18){
          e.hp -= 36;
          spawnImpact(b.x, b.y, Math.atan2(b.y - e.y, b.x - e.x), '#ffb3b3');
          if (e.hp <= 0) e.alive = false;
          playerBullets.splice(i,1);
          break;
        }
      }
    }
  }

  // ---------- Movement & collision ----------
  const keys = {};
  window.addEventListener('keydown', e => {
    keys[e.code] = true;
    // prevent page scroll on these keys
    if (['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault();
    if (e.code === 'KeyR') startReload();
    if (e.code === 'KeyL') loadLevel(currentLevel + 1);
  });
  window.addEventListener('keyup', e => { keys[e.code] = false; });

  canvas.addEventListener('click', e => { canvas.requestPointerLock(); });
  window.addEventListener('mousemove', e => { if (document.pointerLockElement === canvas) player.ang += e.movementX * 0.0024; });

  // touch joystick for mobile
  let touchMove = { x:0, y:0, active:false };
  if (isMobile()){
    touchLeft.style.display = 'block'; touchRight.style.display = 'block';
    function setJoy(x,y){
      const r = joyBase.getBoundingClientRect();
      const cx = r.left + r.width/2, cy = r.top + r.height/2;
      let dx = (x - cx) / (r.width/2), dy = (y - cy) / (r.height/2);
      dx = Math.max(-1, Math.min(1, dx)); dy = Math.max(-1, Math.min(1, dy));
      joyThumb.style.transform = `translate(${dx*36}px,${dy*36}px)`;
      touchMove.x = dx; touchMove.y = dy; touchMove.active = true;
    }
    function resetJoy(){ joyThumb.style.transform = 'translate(0,0)'; touchMove.active = false; touchMove.x = 0; touchMove.y = 0; }
    joyBase.addEventListener('touchstart', e => { e.preventDefault(); setJoy(e.touches[0].clientX, e.touches[0].clientY); });
    joyBase.addEventListener('touchmove', e => { e.preventDefault(); setJoy(e.touches[0].clientX, e.touches[0].clientY); });
    joyBase.addEventListener('touchend', e => { e.preventDefault(); resetJoy(); });
    // right drag to look
    let lastTouchX = null;
    touchRight.addEventListener('touchstart', e => { e.preventDefault(); lastTouchX = e.touches[0].clientX; });
    touchRight.addEventListener('touchmove', e => { e.preventDefault(); const dx = e.touches[0].clientX - lastTouchX; player.ang += dx * 0.007; lastTouchX = e.touches[0].clientX; });
    touchRight.addEventListener('touchend', e => { e.preventDefault(); lastTouchX = null; });
    fireBtn.addEventListener('touchstart', e => { e.preventDefault(); playerFire(); });
    fireBtn.addEventListener('click', e => { e.preventDefault(); playerFire(); });
  }

  // ---------- Raycasting render and HUD ----------
  function castAndRender(){
    // sky/floor
    ctx.fillStyle = '#5a5a66'; ctx.fillRect(0,0,W,H/2);
    ctx.fillStyle = '#0d0d0d'; ctx.fillRect(0,H/2,W,H/2);

    const planeDist = (W/2) / Math.tan(HALF_FOV);
    const colW = W / rays;
    for (let r = 0; r < rays; r++){
      const cameraX = (2 * r / rays) - 1;
      const rayA = player.ang + Math.atan(cameraX * Math.tan(HALF_FOV));
      const res = castSingleRay(player.x, player.y, rayA);
      const corrected = res.dist * Math.cos(rayA - player.ang);
      const h = Math.min(H*2, (TILE * planeDist) / Math.max(0.0001, corrected));
      const drawStart = Math.floor((H/2) - h/2);
      const baseCols = ['#9a9a9a','#7c5c3c','#5c7c3c','#5c5c7c'];
      const idx = (Math.floor(r * 0.03) % baseCols.length + baseCols.length) % baseCols.length;
      const shade = Math.max(0.16, 1 - (corrected / 1600));
      ctx.fillStyle = shadeColor(baseCols[idx], shade);
      ctx.fillRect(r * colW, drawStart, colW + 0.9, Math.max(1, Math.floor(h)));
      // if ray hits exit tile (we can draw a glow)
      if (res.hitExit){
        ctx.fillStyle = 'rgba(110,255,120,0.06)';
        ctx.fillRect(r * colW, drawStart, colW + 0.9, Math.max(1, Math.floor(h)));
      }
    }

    // sprites (enemies)
    const sprites = [];
    const plane = planeDist;
    for (let e of enemies){
      if (!e.alive) continue;
      const dx = e.x - player.x, dy = e.y - player.y;
      const dist = Math.hypot(dx, dy);
      const angTo = Math.atan2(dy, dx);
      let rel = angTo - player.ang; rel = ((rel + Math.PI) % (2*Math.PI)) - Math.PI;
      if (Math.abs(rel) > HALF_FOV + 0.6) continue;
      if (!hasLineOfSight(player.x, player.y, e.x, e.y)) continue;
      const screenX = (0.5 * (1 + Math.tan(rel) / Math.tan(HALF_FOV))) * W;
      const scale = Math.min(1.8, (TILE * plane) / Math.max(1, dist));
      const size = Math.max(8, scale * 44);
      sprites.push({ e, dist, screenX, size });
    }
    sprites.sort((a,b)=>b.dist - a.dist);
    for (let s of sprites){
      const e = s.e;
      const x = s.screenX - s.size/2, y = H/2 - s.size/2;
      ctx.fillStyle = '#c33'; ctx.fillRect(x, y, s.size, s.size);
      const pct = Math.max(0, Math.min(1, e.hp / 100));
      ctx.fillStyle = '#0f0'; ctx.fillRect(x, y - 6, s.size * pct, 4);
      ctx.fillStyle = '#330'; ctx.fillRect(x + s.size * pct, y - 6, s.size * (1 - pct), 4);
    }

    // bullets & particles (projected to screen X)
    for (let b of enemyBullets){
      const sx = projectToScreenX(b.x, b.y);
      if (sx !== null){ ctx.fillStyle = '#ffddaa'; ctx.fillRect(sx-2, H/2 - 2, 4, 4); }
    }
    for (let b of playerBullets){
      const sx = projectToScreenX(b.x, b.y);
      if (sx !== null){ ctx.fillStyle = '#ffeeaa'; ctx.fillRect(sx-2, H/2 - 2, 4, 4); }
    }
    for (let p of particles){
      const sx = projectToScreenX(p.x, p.y);
      if (sx !== null){
        const alpha = Math.max(0, p.life / PARTICLE_LIFE);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color || '#ffd';
        ctx.fillRect(sx - p.size, H/2 - p.size, p.size*2, p.size*2);
        ctx.globalAlpha = 1;
      }
    }

    // crosshair
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(W/2 - 1, H/2 - 12, 2, 24);
    ctx.fillRect(W/2 - 12, H/2 - 1, 24, 2);

    // minimap
    drawMiniMap();
  }

  // single DDA raycast - also detect if hit cell is exit tile
  function castSingleRay(ox, oy, angle){
    let a = angle % (Math.PI*2); if (a < 0) a += Math.PI*2;
    const sin = Math.sin(a), cos = Math.cos(a);
    let mapX = Math.floor(ox / TILE), mapY = Math.floor(oy / TILE);
    const deltaDistX = Math.abs(1 / (cos || 1e-6));
    const deltaDistY = Math.abs(1 / (sin || 1e-6));
    let stepX, stepY, sideDistX, sideDistY;
    if (cos < 0){ stepX = -1; sideDistX = (ox - mapX*TILE) * deltaDistX / TILE; } else { stepX = 1; sideDistX = ((mapX+1)*TILE - ox) * deltaDistX / TILE; }
    if (sin < 0){ stepY = -1; sideDistY = (oy - mapY*TILE) * deltaDistY / TILE; } else { stepY = 1; sideDistY = ((mapY+1)*TILE - oy) * deltaDistY / TILE; }
    let hit=false, side=0, safety=0;
    let hitExit=false;
    while (!hit && safety++ < 4096){
      if (sideDistX < sideDistY){ sideDistX += deltaDistX / TILE; mapX += stepX; side = 0; } else { sideDistY += deltaDistY / TILE; mapY += stepY; side = 1; }
      const c = mapAt(mapX, mapY);
      if (c === '#') hit = true;
      if (c === '>'){ hitExit = true; /* continue until wall so player can see door glow */ }
    }
    if (!hit) return { dist: 1e6, hitExit };
    let hitX, hitY, perpDist;
    if (side === 0){
      const xHit = mapX * TILE + (stepX === -1 ? TILE : 0);
      const t = (xHit - ox) / (cos || 1e-6);
      hitX = ox + cos * t; hitY = oy + sin * t;
      perpDist = Math.abs((hitX - ox) / (cos || 1e-6));
    } else {
      const yHit = mapY * TILE + (stepY === -1 ? TILE : 0);
      const t = (yHit - oy) / (sin || 1e-6);
      hitX = ox + cos * t; hitY = oy + sin * t;
      perpDist = Math.abs((hitY - oy) / (sin || 1e-6));
    }
    return { dist: perpDist, hitX, hitY, side, hitExit };
  }

  // project world point to screen X (null if outside)
  function projectToScreenX(wx, wy){
    const dx = wx - player.x, dy = wy - player.y;
    const ang = Math.atan2(dy, dx);
    let rel = ang - player.ang; rel = ((rel + Math.PI) % (2*Math.PI)) - Math.PI;
    if (Math.abs(rel) > HALF_FOV + 0.6) return null;
    const sx = (0.5 * (1 + Math.tan(rel) / Math.tan(HALF_FOV))) * W;
    return sx;
  }

  function shadeColor(hex, factor){
    const n = parseInt(hex.slice(1), 16);
    const r = Math.floor(((n>>16)&255) * factor);
    const g = Math.floor(((n>>8)&255) * factor);
    const b = Math.floor((n&255) * factor);
    return `rgb(${Math.max(0,r)},${Math.max(0,g)},${Math.max(0,b)})`;
  }

  // ---------- Mini-map drawing ----------
  function drawMiniMap(){
    const scale = 0.14; const pad = 10;
    ctx.save(); ctx.translate(pad, pad); ctx.scale(scale, scale);
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0,0,MAP_W*TILE, MAP_H*TILE);
    // walls
    ctx.fillStyle = '#999';
    for (let y=0;y<MAP_H;y++) for (let x=0;x<MAP_W;x++) if (MAP[y][x] === '#') ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
    // exit tile
    for (let y=0;y<MAP_H;y++) for (let x=0;x<MAP_W;x++) if (MAP[y][x] === '>'){
      ctx.fillStyle = '#7bff7b'; ctx.fillRect(x*TILE + 4, y*TILE + 4, TILE - 8, TILE - 8);
    }
    // enemies
    for (let e of enemies) if (e.alive) { ctx.fillStyle = '#f55'; ctx.beginPath(); ctx.arc(e.x, e.y, 10, 0, Math.PI*2); ctx.fill(); }
    // player
    ctx.fillStyle = '#ff0'; ctx.beginPath(); ctx.arc(player.x, player.y, 10, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = '#ff0'; ctx.beginPath(); ctx.moveTo(player.x, player.y); ctx.lineTo(player.x + Math.cos(player.ang)*40, player.y + Math.sin(player.ang)*40); ctx.stroke();
    ctx.restore();
  }

  // ---------- HUD face (simple reactive face) ----------
  function renderFace(){
    // face reacts to HP: green (healthy) -> red (hurt), eyes widen on damage
    const hpPct = Math.max(0, Math.min(100, player.hp)) / 100;
    faceCtx.clearRect(0,0,84,84);
    // background panel
    faceCtx.fillStyle = '#111'; faceCtx.fillRect(0,0,84,84);
    // face tint
    const r = Math.floor(200*(1-hpPct)+40), g = Math.floor(200*hpPct+40);
    faceCtx.fillStyle = `rgb(${r},${g},40)`;
    faceCtx.fillRect(8,10,68,64);
    // eyes - more squinted when hurt
    faceCtx.fillStyle = '#000';
    const eyeOffsetY = 12 + (1 - hpPct) * 6;
    faceCtx.fillRect(22, eyeOffsetY, 8, 6);
    faceCtx.fillRect(54, eyeOffsetY, 8, 6);
    // mouth - frown when low HP
    faceCtx.fillStyle = '#330';
    const mouthY = 52 + (1 - hpPct) * 6;
    faceCtx.fillRect(30, mouthY, 24, 6);
  }

  // ---------- Movement helpers ----------
  function tryMovePlayer(dx, dy){
    if (!isWallAtWorld(player.x + dx, player.y)) player.x += dx;
    if (!isWallAtWorld(player.x, player.y + dy)) player.y += dy;
  }

  // ---------- Level loader ----------
  function loadLevel(idx){
    currentLevel = idx % LEVELS.length;
    MAP = LEVELS[currentLevel].map;
    MAP_W = MAP[0].length; MAP_H = MAP.length;
    spawnEnemies(LEVELS[currentLevel].spawns);
    player.x = TILE * 3.5; player.y = TILE * 3.5; player.ang = 0.6;
    player.hp = 100; player.ammo = MAX_AMMO; player.reloading = false;
    enemyBullets.length = 0; playerBullets.length = 0; particles.length = 0;
    levelNameEl.textContent = `Level: ${currentLevel + 1} — ${LEVELS[currentLevel].name}`;
    updateHUD();
  }

  // ---------- HUD update ----------
  function updateHUD(){
    hpText.textContent = Math.max(0, Math.round(player.hp));
    ammoText.textContent = player.reloading ? 'Reloading...' : `${player.ammo} / ${MAX_AMMO}`;
  }

  // ---------- Main loop ----------
  let last = performance.now();
  function mainLoop(now){
    const dt = Math.min(0.05, (now - last)/1000);
    last = now;

    // movement
    const speed = 150 * dt;
    const cos = Math.cos(player.ang), sin = Math.sin(player.ang);
    // forward/back
    if (keys['KeyW']) tryMovePlayer(cos*speed, sin*speed);
    if (keys['KeyS']) tryMovePlayer(-cos*speed, -sin*speed);
    // strafing (A/D)
    if (keys['KeyA']) tryMovePlayer(-sin*speed, cos*speed);
    if (keys['KeyD']) tryMovePlayer(sin*speed, -cos*speed);
    // turning by arrows
    if (keys['ArrowLeft']) player.ang -= 2.6 * dt;
    if (keys['ArrowRight']) player.ang += 2.6 * dt;

    // touch move
    if (touchMove.active){
      const jx = touchMove.x, jy = -touchMove.y;
      const mag = Math.hypot(jx, jy);
      if (mag > 0.12){
        const ang = Math.atan2(jy, jx) + player.ang;
        const sp = speed * Math.min(1, mag*1.2);
        tryMovePlayer(Math.cos(ang)*sp, Math.sin(ang)*sp);
      }
    }

    // shooting input (space)
    if (keys['Space'] && !keys._spacePrev){ playerFire(); }
    keys._spacePrev = !!keys['Space'];

    // reload key handled in keydown (startReload)
    // start reload if reloading done (just in case)
    if (player.reloading && performance.now() >= reloadEndAt){ player.reloading = false; player.ammo = MAX_AMMO; updateHUD(); }

    // update logic
    updateEnemies(dt);
    updateBullets(dt);
    updateParticles(dt);

    // flash fade
    if (flashTimer > 0){
      flashTimer -= dt;
      if (flashTimer <= 0) flashEl.style.background = 'rgba(255,0,0,0)';
    }

    // check exit tile collision -> advance level
    if (isExitTileWorld(player.x, player.y)){
      // small delay & feedback
      loadLevel(currentLevel + 1);
    }

    // respawn if player dead (quick reset)
    if (player.hp <= 0){
      loadLevel(currentLevel);
    }

    // render
    castAndRender();
    renderFace();
    updateHUD();

    requestAnimationFrame(mainLoop);
  }

  // ---------- Bullet & enemy updates (wrapped from above functions) ----------
  function updateEnemies(dt){ /* defined earlier */ }
  function updateBullets(dt){ /* defined earlier */ }
  // we need to re-declare functions inside scope - assign from closures above:
  updateEnemies = updateEnemies;
  updateBullets = updateBullets;

  // ---------- Simplify references (they were defined earlier inside the closure) ----------
  // All required functions are already declared above in closure; start loop now.

  // ---------- Input: mouse firing ----------
  canvas.addEventListener('mousedown', e => {
    if (e.button === 0) playerFire();
  });

  // pointer lock request
  canvas.addEventListener('click', () => { canvas.requestPointerLock(); });

  // touch: joystick into touchMove and fire button hooking
  // hook joystick events (already setup earlier)
  if (isMobile()){
    // do nothing extra here; handlers were added above
  }

  // ---------- Start ----------
  loadLevel(0);
  updateHUD();
  requestAnimationFrame(mainLoop);

  // expose debug
  window.__mini = { player, enemies, LEVELS, loadLevel };

  // small helper: ensure events resume audio if used later
  window.addEventListener('pointerdown', ()=>{}, { once:true });

})();
</script>
</body>
</html>
